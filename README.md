# 必读！

本 README 文件将作为项目的核心记录文档，用于记录开发过程中的所有想法、决策及具体操作。其目的在于：
- 帮助梳理和表达开发思路
- 协助团队成员快速了解项目进度、变更内容及背后的原因
- 作为个人学习与成长的记录档案

## 项目原则

在开发过程中，我们将严格遵循以下核心原则：

1. **KISS原则 (Keep It Simple, Stupid)**
   - 保持设计简洁明了，避免不必要的复杂性。

2. **MVP原则 (Minimum Viable Product)**
   - 优先开发核心功能，快速构建可运行的最小可行性产品，避免初期追求大而全。

3. **DRY原则 (Don't Repeat Yourself)**
   - 消除代码冗余，通过抽象和封装实现逻辑复用。

4. **YAGNI原则 (You Aren't Gonna Need It)**
   - 拒绝过度设计，仅开发当前必需的功能，不预研未来可能用不到的特性。

个人建议：
1. 优先面向理解编程，而不是面向实现。需要让代码的执行逻辑符合人类的直觉，让代码易于理解和维护。
2. 允许使用AI进行代码自动补全，但不建议直接交给AI来生成整个代码文件或是让AI大规模修改代码。
3. 确保代码有足够的注释，建议使用大白话进行注释，使代码更易于理解。

## 项目目标

本项目旨在开发一款**AI模型架构可视化设计工具**。通过提供类似 Scratch 的直观节点连线界面，封装可拖拽的AI节点组件模块，实现以下目标：

- **降低门槛**：让非技术人员无需编写代码即可快速搭建或修改模型结构。
- **提升效率**：为研发人员提供高效的架构原型设计与验证环境。
- **促进创新**：降低AI架构设计的技术门槛，加速模型架构的创新迭代。

## 技术栈

- **前端框架**：React
- **可视化库**：React Flow
- **UI组件库**：heroUI
- **构建工具**：Vite
- **前端语言**：JavaScript
- **后端语言**：Python
- **机器学习框架**：PyTorch

## 开发步骤

### 前端开发

1. **基础环境搭建**
   - 安装并导入 React Flow。
   - 实现最基本的节点渲染和连线交互功能。

2. **组件封装**
   - 编写通用的蓝图节点组件。
   - 支持通过配置参数动态生成对应的节点实例。

3. **交互优化**
   - 实现类似 Scratch 的各项操作逻辑。
   - 优化开发与测试流程，提升易用性。

### 后端开发

1. **节点定义系统**
   - 实现节点修饰器的定义逻辑。
   - 支持导出前端所需的节点配置及后端所需的节点对象。

2. **执行引擎**
   - 构建后端节点执行引擎。
   - 能够解析前端定义的蓝图结构与节点参数，自动构建计算图。

3. **验证与评估**
   - 实现架构数据流通性测试。
   - 开发架构性能跑分功能。

### 前后端通信

1. **架构下发**
   - 实现前端将定义好的模型架构发送至后端的接口。
   - 后端接收数据并构建计算图进行执行。

2. **结果反馈**
   - 建立实时反馈机制。
   - 将后端的执行结果实时同步至前端展示。

---

## 执行记录

### 1. 创建项目

执行了 `yarn create` 命令进行项目初始化，配置如下：

- **Project name**: `ai-blueprint`
- **Select a framework**: `React`
- **Select a variant**: `JavaScript`
- **Use rolldown-vite (Experimental)?**: `No`

### 2. 安装依赖

为了集成可视化功能，执行了以下命令安装 React Flow：

```bash
yarn add @xyflow/react
```

### 3. 尝试接入react flow

读了下文档，其实很简单
就是导入 React Flow 提供的组件，然后hook相关的状态管理函数，传给 ReactFlow 组件
哦还有个useCallback，用来优化性能
目前已经更新了 App.jsx 文件，实现了基本的节点渲染和连线交互功能，确保能用。

### 4. 封装通用节点组件

我创建了个BaseNode组件，导入了Handle, Position，然后写了下布局以及节点基础外观。
在App.jsx中，我导入了BaseNode组件，然后在nodeTypes中注册了它。
由于我个人喜欢vue那种的样式写法，不喜欢react里的内联写法和独立文件写法，所以我在BaseNode组件中写了个styles对象，对象式变量写法，把样式写成一个对象，放在文件最底部。

### 5. 编写节点注册表

由于现在还没有后端，我需要编写一个单独的节点注册表文件，模拟已经获取完后端返回的节点列表。
首先思考一下前端这边节点需要什么信息，而且还是要分组的。
我写一个格式：
```json
// 注册表结构
{
  // 按分类组织
  "categories": {
    "node_group1": { "label": "节点组1", "color": "rgb(137, 146, 235)", "nodes": ["node1", "node2"] },
    "node_group2": { "label": "节点组2", "color": "rgb(242, 177, 144)", "nodes": ["node3", "node4"] },
    // ...
  },
  // 节点配置映射
  "nodes": {
    "node1": { /* config */ },
    "node2": { /* config */ },
    "node3": { /* config */ },
    "node4": { /* config */ },
    // ...
  }
}
```
然后具体写一下node1的config：
```json
{
  "label": "节点1",
  "inputs": [{ "id": "in", "label": "输入" }],
  "outputs": [{ "id": "out", "label": "输出" }],
  "params": {
    "param1": { "label": "参数1", "type": "number", "default": 1 },
    "param2": { "label": "参数2", "type": "number", "default": 2 },
  },
}
```
不错，暂时先这样写，感觉还算是合理

### 修改第四点

由于伪类问题，我把styles对象改成了css类名，采用独立的css文件了，然后通过import引入。

### 6. 实现节点面板

现在就是要实现一个类似与scratch编辑器左边那种面板，有分类栏，有节点盒，可以从里面拖出来节点，也可以把节点拖回去删除
我先做节点盒，再做分类栏
但是有个问题，如果用react flow提供的panel组件，会导致很难实现节点节点拖回节点盒删除的功能，主要是显示问题，panel组件永远在最上方，节点无法显示在其上面，得想个办法
我在想要不要在react flow的画布中内置一个节点盒组件，这个节点盒像panel那样不受画布拖动缩放影响，并且显示在最高层级，当然如果有节点在拖拽，那就把当前拖拽的节点们显示在画布的最高层级，节点盒低于它们就行。
现在就是考虑两个问题了，一是怎么让节点盒不受画布缩放影响，二是怎么控制节点盒的层级

后来思考了一下，这个有点复杂，遵循mvp原则，我先直接用panel，拖回节点盒删除的功能以后再说吧

目前以及完成了节点盒的显示，还差拖拽节点盒中的节点到画布生成的功能

### 7. 实现节点拖拽生成功能

实现了从节点盒拖拽节点到画布生成的功能，主要修改了两个文件：

**NodeBox.jsx 修改：**
- 给 NodeItem 组件添加了 `draggable` 属性，使其可拖拽
- 添加了 `onDragStart` 事件处理函数，在拖拽开始时将节点ID存入 `dataTransfer`

**App.jsx 修改：**
- 引入了 `ReactFlowProvider` 包裹组件，因为 `useReactFlow` 这个hook必须在 ReactFlow 组件内部使用
- 将原来的 App 组件拆分为 `FlowCanvas`（内部组件）和 `App`（外层包裹）
- 添加了 `onDrop` 事件处理：获取拖拽的节点ID，将屏幕坐标转换为画布坐标，然后创建新节点
- 添加了 `onDragOver` 事件处理：允许拖拽放置（必须调用 `event.preventDefault()`）
- 使用 `useRef` 维护节点ID计数器，确保每个新节点有唯一ID

**节点生成位置优化：**
- 添加了 `nodeOrigin={[0.5, 0.5]}` 属性，将节点原点从默认的左上角改为中心点
- 这样拖拽生成的节点会以鼠标位置为中心，而不是左上角对齐鼠标
- 好处是动态适应不同大小的节点，无需手动计算偏移量

### 8. 代码重构优化

代码写到一半发现有点乱了，嵌套太多，可读性下降。按照项目原则（KISS、DRY、面向理解编程）进行了一次整体重构。

**优化目标：**
- 减少代码嵌套层级
- 增加大白话注释，让代码更易理解
- 提高模块化程度，松散耦合
- 消除重复逻辑

**nodeRegistry.js 优化：**
- 添加了4个辅助函数，把常用的查询逻辑封装起来：
  - `getNodeConfig(nodeKey)` - 根据节点ID获取配置
  - `findCategoryByNode(nodeKey)` - 根据节点ID找到所属分类
  - `getNodeColor(nodeKey)` - 根据节点ID获取主题色
  - `getAllCategories()` - 获取所有分类（返回数组方便遍历）
- 这样其他文件就不用每次都写一堆查找逻辑了

**BaseNode.jsx 优化：**
- 把原来的 `PortHandle` 组件拆成了 `InputPort` 和 `OutputPort` 两个独立组件
- 原来用条件渲染（`type === 'target'`）来区分输入输出，嵌套了两层
- 现在直接分成两个组件，各管各的，代码更清晰
- 把 data 的解构从参数位置移到函数体内，设置了默认值，更直观

**NodeBox.jsx 优化：**
- 使用新增的辅助函数 `getNodeConfig()` 和 `getAllCategories()`
- 给每个组件都加了大白话注释，解释它是干嘛的
- 删除了没用到的 `groupKey` 参数

**App.jsx 优化：**
- 把 `createNodeFromRegistry` 函数简化为 `createNode`，内部调用辅助函数
- 原来查找节点颜色要写一大段 `Object.keys().find()` 的逻辑，现在一行 `getNodeColor()` 搞定
- 把初始连线数据压缩成单行，减少视觉噪音
- 把连线默认样式抽成常量 `defaultEdgeStyle`
- 给每个函数和代码块都加了注释，用分隔线划分不同区域

### 9. 优化一下操作逻辑

目前只实现了最基本的内容，但是操作还是react flow默认操作，而且缺乏很多需要用到的快捷操作和便捷操作
目前需要进行修改：
先说必要的：
- 增加删除功能，按下del删除键，选中的节点会被删除
- 断开连接功能，不过更准确说是切换连接，因为设定就是只能有一个输入，所以如果鼠标按下的是输入端口，并且存在连接线，那么就会断开连接并立马切换为创建连接线状态，看起来就像是从输入端口拔出插头的感觉，这个时候如果不松开鼠标并移动，那就是还在创建，如果拖到空白的地方那就是彻底把这个连接线删除了
- 限制连接功能，输入端口只能接受一个连接线，毕竟只能接受一个数据，输出端口不受限制，因为输出可以向多个节点发送数据

再说重要的：
- 增加框选功能，如果在画布空白位置按下右键并拖拽，那就是框选模式，框选到的节点会被选中，框选框会显示在画布上
- 历史记录功能也要有，按下ctrl+z可以回退到上一步操作，按下ctrl+y可以重做上一步操作
- 增加复制功能，按下ctrl+c可以复制选中的节点，按下ctrl+v可以在鼠标位置粘贴复制的节点

### 10. 代码模块化重构

App.jsx 代码越写越长，嵌套层级也越来越深，阅读起来很费劲。这次做了一次大规模的模块化拆分，把不同功能的代码分离到独立文件中。

- `useHistory.js`：管理历史记录栈，实现撤销（Ctrl+Z）和重做（Ctrl+Y）
- `useClipboard.js`：管理剪贴板，实现复制（Ctrl+C）和粘贴（Ctrl+V）
- `useKeyboardShortcuts.js`：统一监听键盘事件，调用对应的处理函数
- `createNode.js`：根据节点类型创建 React Flow 需要的节点对象
- `initialData.js`：存放画布启动时默认显示的节点和连线
- `flowConfig.js`：存放 React Flow 组件的配置项（样式、交互行为等）


### 简单记录
写到后面越来越难写记录了，干脆直接写想法和干了什么，不写标题了

然后我现在给拖拽时的连接线也添加了样式，和创建后的连接线样式保持一致

现在发现个问题，节点盒的节点拖拽即使没有离开节点盒，依旧会被创建到画布中，我猜测应该是因为背后也是画布，都在这个区域了，我应该让节点盒和画布并列排布

好了，解决了。

现在就是要写一个分类栏了，然后可以点击分类来筛选节点盒中的节点

分类栏写好了，只不过没有图标

现在丢了点素材进来