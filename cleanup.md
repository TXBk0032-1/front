# AI模型架构蓝图自动整理算法方案

## 一、问题特征分析

您的场景具有以下特殊性，需要对经典算法进行针对性改进：

| 特征     | 传统图布局        | 您的场景         |
| -------- | ----------------- | ---------------- |
| 边连接点 | 节点中心/任意位置 | **固定端口位置** |
| 端口顺序 | 可调整            | **竖向顺序固定** |
| 节点尺寸 | 通常统一          | **尺寸各异**     |
| 图结构   | 任意图            | **通常为DAG**    |

---

## 二、算法整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        输入数据                                  │
│  • 节点: {id, x, y, width, height, inputPorts[], outputPorts[]} │
│  • 边: {sourceNode, sourcePort, targetNode, targetPort}         │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    阶段1: 图预处理                               │
│  • 环检测与临时消除                                              │
│  • 构建邻接关系                                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    阶段2: 层分配                                 │
│  • 拓扑排序确定节点层级                                          │
│  • 处理跨层边（插入虚拟节点）                                     │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                阶段3: 交叉最小化 ⭐核心                          │
│  • 端口感知的重心计算                                            │
│  • 双向层扫描迭代                                                │
│  • 贪婪交换局部优化                                              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    阶段4: 坐标计算                               │
│  • X坐标: 层间距离                                               │
│  • Y坐标: 层内节点位置                                           │
│  • 节点-边重叠避免                                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        输出结果                                  │
│  • 节点新坐标: {id, position: {x, y}}[]                         │
└─────────────────────────────────────────────────────────────────┘
```

---

## 三、各阶段详细算法逻辑

### 阶段1：图预处理

#### 1.1 环检测与消除

**目的**：确保图是DAG，层分配算法才能正确工作

**逻辑**：

```
使用DFS遍历图：
  维护三个集合：未访问、正在访问（栈中）、已完成

  对于每个未访问节点v：
    将v标记为"正在访问"
    对于v的每条出边 v→u：
      如果u"正在访问" → 发现环，记录这条边
      如果u"未访问" → 递归访问u
    将v标记为"已完成"

对于发现的环边：
  临时反转该边方向（记录下来，最后恢复）
```

#### 1.2 构建邻接结构

```
为每个节点建立：
  • inEdges[]: 所有入边列表，每条边记录 {源节点, 源端口, 目标端口}
  • outEdges[]: 所有出边列表，每条边记录 {目标节点, 源端口, 目标端口}
```

---

### 阶段2：层分配

#### 2.1 最长路径法分配层级

**逻辑**：

```
初始化所有节点的层号为-1

找到所有入度为0的节点，设为第0层

使用BFS或拓扑排序：
  对于每个节点v（按拓扑序处理）：
    v的层号 = max(所有前驱节点的层号) + 1

结果：每个节点获得一个层号 layer[v]
```

#### 2.2 虚拟节点插入

**目的**：确保所有边只跨越相邻层，简化后续交叉计算

**逻辑**：

```
对于每条边 e: u → v：
  span = layer[v] - layer[u]

  如果 span > 1：
    删除原边e
    prev = u
    对于 i 从 layer[u]+1 到 layer[v]-1：
      创建虚拟节点 dummy_i，放入第i层
      创建边 prev → dummy_i
      prev = dummy_i
    创建边 prev → v

    虚拟节点记录原边信息：{originalEdge: e, 源端口, 目标端口}
```

**示意图**：

```
原始：                    处理后：
Layer 0    [A]            Layer 0    [A]
             \                         |
              \           Layer 1    (d1) ← 虚拟节点
               \                       |
Layer 2        [B]        Layer 2    [B]
```

---

### 阶段3：交叉最小化（核心算法）

这是整个算法最关键的部分，需要特别处理**端口位置固定**的约束。

#### 3.1 端口感知的交叉计数

**传统方法的问题**：
传统Sugiyama算法假设边从节点中心出发，但您的场景中边从固定端口出发，端口在节点侧边竖向排列。

**端口坐标计算**：

```
对于节点N的第i个输出端口（共n个输出端口）：
  端口Y坐标 = N.y + N.height × (i + 1) / (n + 1)
  端口X坐标 = N.x + N.width（右侧）

对于节点N的第j个输入端口（共m个输入端口）：
  端口Y坐标 = N.y + N.height × (j + 1) / (m + 1)
  端口X坐标 = N.x（左侧）
```

**交叉判定逻辑**：

```
给定相邻两层 L[k] 和 L[k+1] 之间的两条边：
  边1: 节点A的端口p1 → 节点C的端口q1
  边2: 节点B的端口p2 → 节点D的端口q2

计算实际端口Y坐标：
  y_p1 = A的Y坐标 + 端口p1在A中的相对位置
  y_p2 = B的Y坐标 + 端口p2在B中的相对位置
  y_q1 = C的Y坐标 + 端口q1在C中的相对位置
  y_q2 = D的Y坐标 + 端口q2在D中的相对位置

交叉条件：
  如果 (y_p1 < y_p2 且 y_q1 > y_q2) 或 (y_p1 > y_p2 且 y_q1 < y_q2)：
    这两条边交叉
```

**图示说明**：

```
不交叉情况：                    交叉情况：

Layer k    Layer k+1          Layer k    Layer k+1

  ●─────────●                   ●─────────●
  A         C                   A     ╲   C
                                       ╲
  ●─────────●                   ●───────╲─●
  B         D                   B        ╲D

y_p1 < y_p2 且 y_q1 < y_q2     y_p1 < y_p2 但 y_q1 > y_q2
```

#### 3.2 端口感知的重心法

**传统重心法**：节点位置 = 相邻层连接节点位置的平均值

**改进的端口感知重心法**：

```
计算节点v在层内的理想Y位置：

收集所有与v相连的边：
  对于每条入边（来自上一层节点u的端口p到v的端口q）：
    计算"拉力目标点" = u的Y坐标 + 端口p的相对偏移 - 端口q的相对偏移

  对于每条出边（从v的端口p到下一层节点w的端口q）：
    计算"拉力目标点" = w的Y坐标 + 端口q的相对偏移 - 端口p的相对偏移

v的理想Y位置 = 所有"拉力目标点"的加权平均

权重策略：
  • 基础权重：1
  • 如果是关键路径上的边：权重 × 2
  • 如果连接的端口在节点边缘（首/末端口）：权重 × 1.5
```

**直观理解**：

```
                    端口偏移补偿示意

上层节点U          如果U的输出端口在U的下部
    ┌───┐          而V的输入端口在V的上部
    │   ●──────    那么V应该被"拉"到比U更低的位置
    └───┘    │     以减少连线的斜度
             │
             │     理想情况：端口尽量水平对齐
    ┌───┐    │
    ●───┼────┘
    │   │
    └───┘
下层节点V
```

#### 3.3 双向层扫描迭代算法

```
初始化：
  将每层的节点按当前Y坐标排序，得到初始顺序

重复以下过程直到收敛（或达到最大迭代次数，建议8-12次）：

  【向下扫描】从第0层到最后一层：
    对于每一层L[k]（k > 0）：
      对于L[k]中的每个节点v：
        计算v的端口感知重心值（基于L[k-1]层的已确定位置）
      按重心值对L[k]中的节点重新排序

  【向上扫描】从最后一层到第0层：
    对于每一层L[k]（k < 最后一层）：
      对于L[k]中的每个节点v：
        计算v的端口感知重心值（基于L[k+1]层的已确定位置）
      按重心值对L[k]中的节点重新排序

  计算当前总交叉数
  如果交叉数不再减少，提前终止

记录迭代过程中交叉数最少的排列作为结果
```

#### 3.4 贪婪交换局部优化

**目的**：在重心法结果基础上进一步减少交叉

```
对于每一层L[k]：
  changed = true

  当 changed 为 true：
    changed = false

    对于层中相邻的每对节点 (v[i], v[i+1])：
      计算当前交叉数 cross_before（只计算与这两个节点相关的边）

      临时交换 v[i] 和 v[i+1] 的位置
      计算交换后交叉数 cross_after

      如果 cross_after < cross_before：
        保持交换，changed = true
      否则：
        撤销交换

  重复直到没有有益的交换
```

**优化技巧**：

```
增量交叉计算：
  交换两个相邻节点时，只需重新计算与这两个节点相关的边的交叉
  不需要重新计算整层的所有交叉

  受影响的边集合 = v[i]的所有边 ∪ v[i+1]的所有边
  只在这个边集合内检查交叉变化
```

---

### 阶段4：坐标计算

#### 4.1 X坐标分配（层间距离）

```
基础层间距 = 预设值（如200像素）

对于每相邻两层 L[k] 和 L[k+1]：

  计算最小安全距离：
    max_right = L[k]中所有节点的最大(x + width)
    min_left = L[k+1]中所有节点的最小x

    考虑连线需要的空间：
      统计跨越这两层的边数量 edge_count
      连线通道宽度 = edge_count × 单条线间距（如15像素）

    最小距离 = 节点间隙 + 连线通道宽度

  实际层间距 = max(基础层间距, 最小安全距离)

从左到右累加计算每层的X起始位置：
  layer_x[0] = 0
  layer_x[k+1] = layer_x[k] + 第k层最大节点宽度 + 层间距
```

#### 4.2 Y坐标分配（层内位置）

```
对于每一层L[k]，按阶段3确定的顺序排列节点：

方法A - 紧凑布局：
  current_y = 0
  对于层中每个节点v（按顺序）：
    v.y = current_y
    current_y = current_y + v.height + 节点间距（如30像素）

方法B - 重心对齐布局（推荐）：
  先用方法A得到初始位置
  然后微调：
    对于每个节点v：
      计算v的端口感知重心目标位
```

```
方法B - 重心对齐布局（推荐，续）：
  先用方法A得到初始位置
  然后微调：
    对于每个节点v：
      计算v的端口感知重心目标位置 target_y

      检查移动到target_y是否会与相邻节点重叠：
        上方节点的下边界 = prev_node.y + prev_node.height + 最小间距
        下方节点的上边界 = next_node.y - 最小间距 - v.height

      v.y = clamp(target_y, 上方节点的下边界, 下方节点的上边界)

  迭代2-3次直到位置稳定
```

#### 4.3 节点-边重叠避免（关键创新点）

**问题描述**：

```
常见问题场景：

    [A]─────────────────────┐
                            │
    [B]──────┐              │   ← B的出边可能穿过节点C
             │              │
    [C]──────┼──────────────┼───→ [D]
             │              │
             └──────────────┼───→ [E]
                            │
                            └───→ [F]
```

**检测逻辑**：

```
对于每条边 e: 从节点S的端口p → 节点T的端口q：

  计算边的路径包围盒：
    起点坐标 (x1, y1) = S的端口p的实际坐标
    终点坐标 (x2, y2) = T的端口q的实际坐标

    边包围盒 = {
      left: min(x1, x2),
      right: max(x1, x2),
      top: min(y1, y2) - 线宽余量,
      bottom: max(y1, y2) + 线宽余量
    }

  对于起点和终点之间所有层的节点N（排除S和T）：
    如果 N的包围盒 与 边包围盒 相交：
      进一步检查：边的直线是否真正穿过N

      使用线段与矩形相交检测：
        检查边线段是否与N的四条边中任意一条相交
        或者边的任一端点是否在N内部

      如果相交 → 标记为冲突
```

**线段与矩形相交检测**：

```
线段 (x1,y1)→(x2,y2) 与矩形 (rx, ry, rw, rh) 的相交判定：

1. 快速排斥测试：
   如果线段包围盒与矩形不相交 → 不相交

2. 检查线段与矩形四边的交点：
   对于矩形的每条边（上、下、左、右）：
     使用线段相交公式检查

   线段相交公式（两线段AB和CD）：
     d = (B-A) × (D-C)  // 叉积
     如果 d ≈ 0 → 平行
     t = ((C-A) × (D-C)) / d
     u = ((C-A) × (B-A)) / d
     如果 0 ≤ t ≤ 1 且 0 ≤ u ≤ 1 → 相交
```

**解决策略 - 垂直位移法**：

```
当检测到节点N被边e穿过时：

计算边e在N所在X位置的Y坐标：
  edge_y_at_N = y1 + (y2 - y1) × (N.x - x1) / (x2 - x1)

判断N应该向上还是向下移动：
  N_center_y = N.y + N.height / 2

  如果 edge_y_at_N < N_center_y：
    // 边从N的上半部分穿过，N应该下移
    移动方向 = 下
    最小移动距离 = edge_y_at_N - N.y + 安全边距
  否则：
    // 边从N的下半部分穿过，N应该上移
    移动方向 = 上
    最小移动距离 = (N.y + N.height) - edge_y_at_N + 安全边距

检查移动是否会导致与其他节点重叠：
  如果会重叠 → 级联移动相邻节点
```

**解决策略 - 水平通道法（备选）**：

```
如果垂直位移代价过大，考虑调整层间距：

在冲突位置的两层之间增加额外间距：
  找到所有穿过该区域的边
  计算需要的最小通道宽度
  增加该区域的层间距

这种方法保持节点Y坐标不变，但增加水平空间
```

**迭代解决流程**：

```
max_iterations = 10
iteration = 0

重复：
  conflicts = 检测所有节点-边冲突()

  如果 conflicts 为空 或 iteration >= max_iterations：
    退出循环

  按冲突严重程度排序（穿过节点中心的优先处理）

  对于每个冲突：
    尝试垂直位移解决
    如果位移会导致新冲突：
      尝试水平通道法
    更新节点位置

  iteration += 1
```

---

### 阶段5：后处理与优化

#### 5.1 虚拟节点移除与边路径还原

```
对于每个虚拟节点序列（代表一条原始长边）：

  获取原始边信息：源节点S，目标节点T，源端口，目标端口

  收集虚拟节点的Y坐标作为边的中间路径点：
    waypoints = []
    对于每个虚拟节点dummy：
      waypoints.append({
        x: dummy.x,
        y: dummy.y + dummy.height/2  // 虚拟节点中心
      })

  生成带弯折的边路径（用于React Flow的edge配置）：
    edge.type = 'smoothstep' 或 'bezier'
    edge.data.waypoints = waypoints

  删除虚拟节点
```

#### 5.2 边路由优化

```
对于每条边，选择最佳路由类型：

分析边的几何特征：
  dy = |目标端口Y - 源端口Y|
  dx = 目标节点X - 源节点X

  如果 dy < 阈值（如20像素）：
    // 近似水平，使用直线
    edge.type = 'straight'

  如果 dy/dx > 0.5：
    // 斜率较大，使用平滑曲线避免视觉混乱
    edge.type = 'bezier'

  否则：
    // 标准情况，使用阶梯线
    edge.type = 'smoothstep'
```

#### 5.3 整体布局居中

```
计算所有节点的包围盒：
  min_x = min(所有节点的x)
  max_x = max(所有节点的x + width)
  min_y = min(所有节点的y)
  max_y = max(所有节点的y + height)

计算画布中心偏移：
  offset_x = (画布宽度 - (max_x - min_x)) / 2 - min_x
  offset_y = (画布高度 - (max_y - min_y)) / 2 - min_y

应用偏移到所有节点：
  对于每个节点：
    node.x += offset_x
    node.y += offset_y
```

---

## 四、算法复杂度分析

| 阶段         | 时间复杂度         | 空间复杂度 | 说明                               |
| ------------ | ------------------ | ---------- | ---------------------------------- |
| 环检测       | O(V + E)           | O(V)       | V=节点数, E=边数                   |
| 层分配       | O(V + E)           | O(V)       | 拓扑排序                           |
| 虚拟节点插入 | O(E × L)           | O(E × L)   | L=最大层跨度                       |
| 交叉最小化   | O(I × L × N² × P²) | O(V + E)   | I=迭代次数, N=层内节点数, P=端口数 |
| 坐标计算     | O(V + E)           | O(V)       | 线性扫描                           |
| 重叠检测     | O(E × V)           | O(1)       | 可用空间索引优化                   |

**实际性能预估**（基于典型AI模型图规模）：

| 图规模 | 节点数  | 边数    | 预计耗时  |
| ------ | ------- | ------- | --------- |
| 小型   | 10-30   | 15-50   | < 50ms    |
| 中型   | 50-100  | 80-200  | 100-300ms |
| 大型   | 200-500 | 300-800 | 500ms-2s  |

---

## 五、React Flow 集成要点

#### 5.1 数据结构映射

```
React Flow 节点结构：
{
  id: string,
  position: { x: number, y: number },  ← 算法输出
  data: {
    label: string,
    inputHandles: string[],   // 输入端口ID列表（已排序）
    outputHandles: string[]   // 输出端口ID列表（已排序）
  },
  width: number,   // 需要先渲染获取，或预设
  height: number
}

React Flow 边结构：
{
  id: string,
  source: string,        // 源节点ID
  sourceHandle: string,  // 源端口ID
  target: string,        // 目标节点ID
  targetHandle: string,  // 目标端口ID
  type: 'smoothstep' | 'bezier' | 'straight'
}
```

#### 5.2 端口位置获取

```
在React Flow中获取实际端口位置：

方法1 - 基于约定计算（推荐）：
  假设端口均匀分布在节点侧边
  port_y = node.y + node.height × (port_index + 1) / (total_ports + 1)

方法2 - DOM查询（精确但较慢）：
  使用 document.querySelector(`[data-handleid="${handleId}"]`)
  获取handle元素的getBoundingClientRect()
  转换为React Flow坐标系
```

#### 5.3 调用时机建议

```
布局触发时机：
  1. 用户点击"自动整理"按钮
  2. 导入新图时
  3. 批量添加节点后

避免频繁触发：
  • 单个节点拖拽时不触发
  • 添加单条边时不触发
  • 使用防抖处理批量操作
```

---

## 六、特殊场景处理

#### 6.1 多连通分量

```
如果图包含多个不连通的子图：

1. 使用DFS/BFS识别所有连通分量
2. 对每个连通分量独立执行布局算法
3. 将各分量水平或垂直排列：

   水平排列（推荐）：
   ┌─────────┐  ┌─────────┐  ┌─────────┐
   │ 分量1   │  │ 分量2   │  │ 分量3   │
   │         │  │         │  │         │
   └─────────┘  └─────────┘  └─────────┘

   各分量之间保持固定间距（如100像素）
```

#### 6.2 双向边处理

```
如果存在 A→B 和 B→A 两条边：

方案1 - 曲线分离：
  A→B 使用上弧线
  B→A 使用下弧线

方案2 - 偏移分离：
  两条边在Y方向上略微偏移
  避免完全重叠
```

#### 6.3 自环边处理

```
如果存在 A→A 的自环边：

不参与层分配和交叉计算
单独渲染为节点旁边的环形：

  ┌───┐ ╭──╮
  │ A │─╯  │
  │   │←───╯
  └───┘
```

---

## 七、优化建议与扩展

#### 7.1 性能优化策略

```
1. 增量布局：
   当只添加少量节点时，固定大部分节点位置
   只对新节点及其邻居进行局部调整

2. 空间索引：
   使用四叉树或R树加速重叠检测
   将O(E×V)降低到O(E×logV)

3. Web Worker：
   将布局计算放入Web Worker
   避免阻塞UI线程

4. 分层缓存：
   缓存每层的交叉计数
   只在相关节点变化时重新计算
```

#### 7.2 用户体验增强

```
1. 动画过渡：
   使用React Flow的动画功能
   从旧位置平滑过渡到新位置
   duration: 300-500ms

2. 布局预览：
   在确认前显示布局预览
   允许用户撤销

3. 局部锁定：
   允许用户锁定某些节点位置
   算法只调整未锁定节点
```

---

## 八、算法验证清单

在实施前，建议通过以下测试用例验证算法正确性：

| 测试场景               | 验证点         | 预期结果           |
| ---------------------- | -------------- | ------------------ |
| 简单链式图 A→B→C→D     | 层分配正确性   | 4层，每层1节点     |
| 菱形图 A→B,A→C,B→D,C→D | 交叉最小化     | 0交叉              |
| 多端口节点             | 端口感知计算   | 端口对齐优化       |
| 跨层长边               | 虚拟节点插入   | 边路径平滑         |
| 节点遮挡边             | 重叠检测与解决 | 无遮挡             |
| 包含环的图             | 环处理         | 正确布局，环边标记 |
| 大规模图(100+节点)     | 性能           | < 1秒完成          |

---

## 九、总结

本方案的核心创新点：

1. **端口感知的交叉计算**：不同于传统算法假设边从节点中心出发，本方案精确计算端口位置对交叉的影响

2. **端口感知的重心法**：在计算节点理想位置时，考虑端口偏移量，使连线更趋于水平

3. **节点-边重叠检测与解决**：传统Sugiyama算法不处理此问题，本方案增加专门的后处理阶段

4. **React Flow适配**：数据结构和调用方式针对React Flow优化
